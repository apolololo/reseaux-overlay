<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Followers Goal Overlay</title>
  <link rel="stylesheet" href="./overlay.css">
</head>
<body>
  <div class="followers-goal-container">
    <div class="goal-header">
      <h2 class="goal-title">Objectif Followers</h2>
    </div>
    
    <div class="followers-info">
      <div class="current-followers">
        <span class="followers-count" id="current-count">0</span>
        <span class="followers-label">Followers</span>
      </div>
      
      <div class="goal-separator">/</div>
      
      <div class="goal-followers">
        <span class="goal-count" id="goal-count">1000</span>
        <span class="goal-label">Objectif</span>
      </div>
    </div>
    
    <div class="progress-container">
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div class="progress-percentage" id="progress-percentage">0%</div>
    </div>
    
    <div class="remaining-info">
      <span class="remaining-text">Plus que <span id="remaining-count">1000</span> followers !</span>
    </div>
    
    <div id="debug-info" style="display: none; position: absolute; bottom: 5px; left: 5px; font-size: 10px; color: #666; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px;"></div>
  </div>

  <script>
    class FollowersGoal {
      constructor() {
        this.currentFollowers = 0;
        this.goalFollowers = 1000;
        this.debugMode = window.location.search.includes('debug=true');
        this.lastFetchTime = 0;
        this.isOBSContext = this.detectOBSContext();
        this.lastConfigTimestamp = 0;
        this.lastFollowersTimestamp = 0;
        this.configChannels = [];
        this.fastPollingInterval = null;
        this.ultraFastConfigCheck = null;
        this.syncCheckInterval = null;
        this.init();
      }
      
      detectOBSContext() {
        try {
          return window.self !== window.top || 
                 navigator.userAgent.includes('OBS') ||
                 document.referrer.includes('obs') ||
                 window.location !== window.parent.location;
        } catch (e) {
          return true;
        }
      }
      
      debugLog(message, data = null) {
        if (this.debugMode) {
          console.log(`[FollowersGoal] ${message}`, data || '');
          const debugElement = document.getElementById('debug-info');
          if (debugElement) {
            debugElement.style.display = 'block';
            debugElement.innerHTML = `${new Date().toLocaleTimeString()}: ${message}`;
          }
        }
      }

      init() {
        this.debugLog(`=== INITIALISATION DU WIDGET ULTRA-AVANCÉE ===`);
        this.debugLog(`Contexte OBS: ${this.isOBSContext}`);
        this.loadSettings();
        this.updateDisplay();
        this.startFastPolling();
        this.setupUltraAdvancedConfigSync();
        this.setupAdvancedMessageListener();
        this.startUltraFastSyncChecker();
      }

      setupUltraAdvancedConfigSync() {
        this.debugLog('=== CONFIGURATION SYNCHRONISATION ULTRA-AVANCÉE ===');
        
        // 1. Multiples BroadcastChannels pour redondance
        if (typeof BroadcastChannel !== 'undefined') {
          const channelNames = [
            'followers_goal_config',
            'followers_goal_sync',
            'followers_goal_force_update'
          ];
          
          channelNames.forEach(name => {
            try {
              const channel = new BroadcastChannel(name);
              channel.addEventListener('message', (event) => {
                this.debugLog(`📡 BroadcastChannel ${name}:`, event.data.type);
                this.handleConfigMessage(event.data);
              });
              this.configChannels.push(channel);
            } catch (e) {
              this.debugLog(`⚠️ Channel ${name} échoué:`, e);
            }
          });
          
          if (this.configChannels.length > 0) {
            this.debugLog(`✅ ${this.configChannels.length} BroadcastChannels configurés`);
          }
        }
        
        // 2. Surveillance ultra-agressive du localStorage (50ms!)
        this.ultraFastConfigCheck = setInterval(() => {
          this.checkConfigChanges();
          this.checkFollowersChanges();
        }, 50);
        
        // 3. Surveillance des événements storage
        window.addEventListener('storage', (event) => {
          if (event.key && event.key.includes('followers_goal')) {
            this.debugLog('📦 Storage event:', event.key);
            this.checkConfigChanges();
            this.checkFollowersChanges();
          }
        });
        
        this.debugLog('🚀 Synchronisation ultra-avancée configurée');
      }

      setupAdvancedMessageListener() {
        // Écouter TOUS les types de messages possibles
        window.addEventListener('message', (event) => {
          this.handleConfigMessage(event.data);
        });
        
        // Écouter les hash changes (backup)
        window.addEventListener('hashchange', () => {
          this.debugLog('🔄 Hash change détecté, rechargement config');
          this.checkConfigChanges();
        });
        
        // Écouter les focus events (quand la fenêtre devient active)
        window.addEventListener('focus', () => {
          this.debugLog('👁️ Focus event, rechargement config');
          this.checkConfigChanges();
        });
      }

      handleConfigMessage(data) {
        if (!data || !data.type) return;
        
        if (data.type === 'followers_goal_config_update' || 
            data.type === 'config_update') {
          this.debugLog('🔄 Message config reçu:', data.source || 'unknown');
          this.handleConfigUpdate(data.config, data.currentFollowers);
        }
        
        if (data.type === 'followers_goal_sync_check') {
          this.debugLog('🔍 Sync check reçu:', data.source || 'unknown');
          const localTimestamp = this.lastConfigTimestamp;
          const remoteTimestamp = data.timestamp || 0;
          
          if (remoteTimestamp > localTimestamp || data.force) {
            this.debugLog(`📥 Sync: Remote plus récent (${remoteTimestamp} > ${localTimestamp})`);
            this.handleConfigUpdate(data.config, data.currentFollowers);
          }
        }
      }

      startUltraFastSyncChecker() {
        // Vérificateur de synchronisation ULTRA-RAPIDE (200ms)
        this.syncCheckInterval = setInterval(() => {
          this.checkConfigChanges();
          this.checkFollowersChanges();
          
          // Envoyer un ping vers le parent TRÈS fréquemment
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({
                type: 'followers_goal_ping',
                timestamp: Date.now(),
                source: 'overlay_widget_ultra_ping'
              }, '*');
            }
          } catch (e) {
            // Silent fail
          }
        }, 200); // 200ms au lieu de 500ms
      }

      loadSettings() {
        this.debugLog('=== CHARGEMENT DES PARAMÈTRES ULTRA-AVANCÉ ===');
        
        const urlParams = new URLSearchParams(window.location.search);
        const goal = urlParams.get('goal');
        const current = urlParams.get('current');
        
        const configStr = localStorage.getItem('followers_goal_config');
        let config = {};
        
        if (configStr) {
          try {
            config = JSON.parse(configStr);
            this.debugLog('📋 Configuration chargée:', config);
          } catch (e) {
            this.debugLog('❌ Erreur parsing config:', e);
          }
        }
        
        // Chargement des paramètres avec priorité URL > Config > Défaut
        if (goal) {
          this.goalFollowers = parseInt(goal);
        } else if (config.goal) {
          this.goalFollowers = config.goal;
        }
        
        if (current) {
          this.currentFollowers = parseInt(current);
        } else {
          const cachedFollowers = localStorage.getItem('current_followers_count');
          if (cachedFollowers) {
            this.currentFollowers = parseInt(cachedFollowers);
          }
        }
        
        // Appliquer la configuration IMMÉDIATEMENT
        if (config && Object.keys(config).length > 0) {
          this.applyStyles(config);
        }
        
        // Charger les timestamps
        const configTimestamp = localStorage.getItem('followers_goal_config_timestamp');
        if (configTimestamp) {
          this.lastConfigTimestamp = parseInt(configTimestamp);
        }
        
        const followersTimestamp = localStorage.getItem('current_followers_timestamp');
        if (followersTimestamp) {
          this.lastFollowersTimestamp = parseInt(followersTimestamp);
        }
        
        this.debugLog('⚙️ Paramètres finaux:', { 
          goal: this.goalFollowers, 
          current: this.currentFollowers,
          configTimestamp: this.lastConfigTimestamp
        });
      }

      checkConfigChanges() {
        const configTimestamp = localStorage.getItem('followers_goal_config_timestamp');
        if (configTimestamp) {
          const timestamp = parseInt(configTimestamp);
          if (timestamp > this.lastConfigTimestamp) {
            this.debugLog('🆕 Nouveau timestamp config détecté');
            this.debugLog(`Ancien: ${this.lastConfigTimestamp}, Nouveau: ${timestamp}`);
            this.lastConfigTimestamp = timestamp;
            
            // Recharger et appliquer IMMÉDIATEMENT
            const configStr = localStorage.getItem('followers_goal_config');
            if (configStr) {
              try {
                const config = JSON.parse(configStr);
                this.debugLog('🔄 Application nouvelle config:', config);
                this.applyStyles(config);
                this.updateDisplay();
              } catch (e) {
                this.debugLog('❌ Erreur application config:', e);
              }
            }
          }
        }
      }

      checkFollowersChanges() {
        const followersTimestamp = localStorage.getItem('current_followers_timestamp');
        if (followersTimestamp) {
          const timestamp = parseInt(followersTimestamp);
          if (timestamp > this.lastFollowersTimestamp) {
            this.debugLog('🆕 Nouveau timestamp followers détecté');
            this.lastFollowersTimestamp = timestamp;
            const newFollowers = localStorage.getItem('current_followers_count');
            if (newFollowers && parseInt(newFollowers) !== this.currentFollowers) {
              this.currentFollowers = parseInt(newFollowers);
              this.debugLog(`👥 Followers mis à jour: ${this.currentFollowers}`);
              this.updateDisplay();
            }
          }
        }
      }

      handleConfigUpdate(config, currentFollowers) {
        this.debugLog('🔄 TRAITEMENT MISE À JOUR CONFIG ULTRA-AVANCÉ');
        
        let hasChanges = false;
        
        if (config) {
          localStorage.setItem('followers_goal_config', JSON.stringify(config));
          localStorage.setItem('followers_goal_config_timestamp', Date.now().toString());
          this.lastConfigTimestamp = Date.now();
          
          if (config.goal && config.goal !== this.goalFollowers) {
            this.goalFollowers = config.goal;
            hasChanges = true;
            this.debugLog(`🎯 Objectif mis à jour: ${config.goal}`);
          }
          
          this.applyStyles(config);
          hasChanges = true;
        }
        
        if (currentFollowers && parseInt(currentFollowers) !== this.currentFollowers) {
          this.currentFollowers = parseInt(currentFollowers);
          localStorage.setItem('current_followers_count', currentFollowers);
          localStorage.setItem('current_followers_timestamp', Date.now().toString());
          this.debugLog(`👥 Followers mis à jour: ${currentFollowers}`);
          hasChanges = true;
        }
        
        if (hasChanges) {
          this.updateDisplay();
        }
      }

      applyStyles(config) {
        if (!config) return;
        
        this.debugLog('🎨 APPLICATION STYLES ULTRA-AVANCÉE', config);
        
        // Mise à jour du titre avec forçage
        if (config.title) {
          const titleEl = document.querySelector('.goal-title');
          if (titleEl && titleEl.textContent !== config.title) {
            titleEl.textContent = config.title;
            this.debugLog(`📝 Titre appliqué: ${config.title}`);
          }
        }
        
        // Mise à jour de l'objectif
        if (config.goal && config.goal !== this.goalFollowers) {
          this.goalFollowers = config.goal;
          const goalCountEl = document.getElementById('goal-count');
          if (goalCountEl) {
            goalCountEl.textContent = this.goalFollowers.toLocaleString();
          }
          this.debugLog(`🎯 Objectif appliqué: ${config.goal}`);
        }
        
        // Application des couleurs avec forçage !important
        const container = document.querySelector('.followers-goal-container');
        const root = document.documentElement;
        
        if (config.bgColor) {
          if (container) {
            container.style.setProperty('background', config.bgColor, 'important');
            container.style.setProperty('background-color', config.bgColor, 'important');
          }
          root.style.setProperty('--primary-color', config.bgColor);
          this.debugLog(`🌈 BG appliqué: ${config.bgColor}`);
        }
        
        if (config.textColor) {
          const textSelectors = [
            '.goal-title', '.followers-count', '.goal-count',
            '.followers-label', '.goal-label', '.progress-percentage',
            '.remaining-text', '.goal-separator'
          ];
          
          textSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
              el.style.setProperty('color', config.textColor, 'important');
            });
          });
          
          root.style.setProperty('--text-primary', config.textColor);
          this.debugLog(`✏️ Texte appliqué: ${config.textColor}`);
        }
        
        if (config.progressColor) {
          const progressFill = document.getElementById('progress-fill');
          if (progressFill) {
            progressFill.style.setProperty('background', config.progressColor, 'important');
            progressFill.style.setProperty('background-color', config.progressColor, 'important');
          }
          root.style.setProperty('--secondary-color', config.progressColor);
          this.debugLog(`📊 Progression appliquée: ${config.progressColor}`);
        }
        
        // Application des styles de thème
        if (config.style) {
          document.body.className = document.body.className
            .split(' ')
            .filter(cls => !cls.startsWith('style-'))
            .join(' ');
          
          document.body.classList.add(`style-${config.style}`);
          this.applyStyleTheme(config.style);
          this.debugLog(`🎭 Style appliqué: ${config.style}`);
        }
        
        // Forcer la mise à jour visuelle
        this.forceStyleUpdate();
      }

      applyStyleTheme(style) {
        const container = document.querySelector('.followers-goal-container');
        if (!container) return;
        
        // Reset des styles personnalisés
        container.style.removeProperty('border-radius');
        container.style.removeProperty('box-shadow');
        container.style.removeProperty('border');
        
        switch (style) {
          case 'minimal':
            container.style.setProperty('border-radius', '5px', 'important');
            container.style.setProperty('box-shadow', 'none', 'important');
            container.style.setProperty('border', '1px solid rgba(255,255,255,0.2)', 'important');
            break;
          case 'classic':
            container.style.setProperty('border-radius', '10px', 'important');
            container.style.setProperty('box-shadow', '0 4px 8px rgba(0,0,0,0.3)', 'important');
            break;
          case 'neon':
            container.style.setProperty('border-radius', '15px', 'important');
            container.style.setProperty('box-shadow', '0 0 20px rgba(145, 70, 255, 0.5), inset 0 0 20px rgba(145, 70, 255, 0.1)', 'important');
            container.style.setProperty('border', '2px solid #9146FF', 'important');
            break;
          default: // modern
            container.style.setProperty('border-radius', '20px', 'important');
            break;
        }
      }
      
      forceStyleUpdate() {
        // Forcer le navigateur à recalculer les styles
        const container = document.querySelector('.followers-goal-container');
        if (container) {
          container.style.display = 'none';
          container.offsetHeight; // Force reflow
          container.style.display = '';
        }
      }

      updateDisplay() {
        const currentCountEl = document.getElementById('current-count');
        const goalCountEl = document.getElementById('goal-count');
        const progressFillEl = document.getElementById('progress-fill');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const remainingCountEl = document.getElementById('remaining-count');

        if (currentCountEl) currentCountEl.textContent = this.currentFollowers.toLocaleString();
        if (goalCountEl) goalCountEl.textContent = this.goalFollowers.toLocaleString();

        const percentage = Math.min((this.currentFollowers / this.goalFollowers) * 100, 100);
        const remaining = Math.max(this.goalFollowers - this.currentFollowers, 0);

        if (progressFillEl) {
          progressFillEl.style.width = `${percentage}%`;
        }
        
        if (progressPercentageEl) {
          progressPercentageEl.textContent = `${Math.round(percentage)}%`;
        }
        
        if (remainingCountEl) {
          remainingCountEl.textContent = remaining.toLocaleString();
        }

        const remainingInfo = document.querySelector('.remaining-info');
        if (remainingInfo) {
          remainingInfo.style.display = remaining > 0 ? 'block' : 'none';
        }

        const container = document.querySelector('.followers-goal-container');
        if (container) {
          if (this.currentFollowers >= this.goalFollowers) {
            container.classList.add('goal-reached');
          } else {
            container.classList.remove('goal-reached');
          }
        }
        
        localStorage.setItem('current_followers_count', this.currentFollowers.toString());
        
        this.debugLog(`=== AFFICHAGE MIS À JOUR ===`);
        this.debugLog(`Followers: ${this.currentFollowers}/${this.goalFollowers} (${Math.round(percentage)}%)`);
      }

      async fetchFollowersCount() {
        const now = Date.now();
        this.debugLog(`=== RÉCUPÉRATION DES FOLLOWERS ===`);
        
        try {
          const token = localStorage.getItem('twitch_token');
          const userData = localStorage.getItem('twitch_user');
          
          if (!token || !userData) {
            this.debugLog('Token ou données utilisateur manquants');
            const savedFollowers = localStorage.getItem('current_followers_count');
            if (savedFollowers) {
              this.currentFollowers = parseInt(savedFollowers);
              this.debugLog('Utilisation du cache', this.currentFollowers);
              this.updateDisplay();
            }
            return;
          }

          try {
            const user = JSON.parse(userData);
            if (!user || !user.id) {
              this.debugLog('Données utilisateur invalides', userData);
              return;
            }
            
            const broadcasterId = user.id;
            this.debugLog(`Récupération pour broadcaster ID: ${broadcasterId}`);

            const response = await fetch(`https://api.twitch.tv/helix/channels/followers?broadcaster_id=${broadcasterId}`, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Client-Id': 'z8q1w4g12yrql6cyb5zzwmhe1pnxyn'
              }
            });

            this.debugLog(`Réponse API: ${response.status} ${response.statusText}`);

            if (response.ok) {
              const data = await response.json();
              this.debugLog('Données reçues', data);
              
              let newFollowerCount = null;
              
              if (data && typeof data.total === 'number') {
                newFollowerCount = data.total;
                this.debugLog('Followers depuis total', newFollowerCount);
              } else if (data && data.total_count !== undefined) {
                newFollowerCount = data.total_count;
                this.debugLog('Followers depuis total_count', newFollowerCount);
              } else if (data && data.data && Array.isArray(data.data)) {
                if (data.data.length > 0 && data.data[0].follower_count !== undefined) {
                  newFollowerCount = data.data[0].follower_count;
                  this.debugLog('Followers depuis follower_count', newFollowerCount);
                }
              }
              
              if (newFollowerCount !== null) {
                if (newFollowerCount !== this.currentFollowers) {
                  this.debugLog(`=== CHANGEMENT DE FOLLOWERS: ${this.currentFollowers} -> ${newFollowerCount} ===`);
                  this.currentFollowers = newFollowerCount;
                  
                  localStorage.setItem('current_followers_count', this.currentFollowers.toString());
                  localStorage.setItem('current_followers_timestamp', Date.now().toString());
                  this.updateDisplay();
                  
                  if (this.configChannel) {
                    this.configChannel.postMessage({
                      type: 'follower_count_update',
                      currentFollowers: this.currentFollowers,
                      timestamp: Date.now()
                    });
                  }
                } else {
                  this.debugLog('Aucun changement de followers détecté');
                }
              } else {
                this.debugLog('Pas de données de followers trouvées, utilisation du cache');
                const savedFollowers = localStorage.getItem('current_followers_count');
                if (savedFollowers) {
                  this.currentFollowers = parseInt(savedFollowers);
                }
              }
              
              this.lastFetchTime = now;
              this.updateDisplay();
              
            } else {
              this.debugLog(`Erreur API: ${response.status}`);
              const savedFollowers = localStorage.getItem('current_followers_count');
              if (savedFollowers) {
                this.currentFollowers = parseInt(savedFollowers);
                this.debugLog('Utilisation du cache après erreur', this.currentFollowers);
                this.updateDisplay();
              }
            }
          } catch (parseError) {
            this.debugLog('Erreur parsing utilisateur', parseError);
          }
        } catch (error) {
          this.debugLog('Erreur générale', error);
          
          const savedFollowers = localStorage.getItem('current_followers_count');
          if (savedFollowers) {
            this.currentFollowers = parseInt(savedFollowers);
            this.debugLog('Utilisation du cache après exception', this.currentFollowers);
            this.updateDisplay();
          }
        }
      }

      startFastPolling() {
        this.debugLog('=== DÉMARRAGE POLLING ULTRA-RAPIDE ===');
        
        this.fetchFollowersCount();
        
        // Polling encore plus rapide (1.5 secondes)
        this.fastPollingInterval = setInterval(() => {
          this.fetchFollowersCount();
        }, 1500);
        
        this.debugLog('⏱️ Polling configuré toutes les 1.5 secondes');
      }
      
      destroy() {
        if (this.fastPollingInterval) {
          clearInterval(this.fastPollingInterval);
        }
        if (this.ultraFastConfigCheck) {
          clearInterval(this.ultraFastConfigCheck);
        }
        if (this.syncCheckInterval) {
          clearInterval(this.syncCheckInterval);
        }
        this.configChannels.forEach(channel => {
          try {
            channel.close();
          } catch (e) {
            // Silent fail
          }
        });
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      window.followersGoalWidget = new FollowersGoal();
    });
    
    window.addEventListener('beforeunload', () => {
      if (window.followersGoalWidget) {
        window.followersGoalWidget.destroy();
      }
    });
  </script>
</body>
</html>
